// Code generated by go-swagger; DO NOT EDIT.


{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}


package {{ .APIPackage }}

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"sync"
	"sync/atomic"
	"syscall"
	"time"

  "github.com/go-openapi/swag"
  {{ if .UseGoStructFlags }}flags "github.com/jessevdk/go-flags"
  {{ end -}}
  "github.com/go-openapi/runtime/flagext"
  {{ if .UsePFlags }}flag "github.com/spf13/pflag"
  {{ end -}}
  {{ if .UseFlags }}"flag"
  "strings"
  {{ end -}}
  "golang.org/x/net/netutil"

  "github/user-manager/config"
  {{ imports .DefaultImports }}
  {{ imports .Imports }}
)

{{ if not .UseGoStructFlags}}
var ({{ if .ExcludeSpec }}
  specFile         string
  {{ end }}enabledListeners []string
  cleanupTimeout   time.Duration
  gracefulTimeout  time.Duration
  maxHeaderSize    flagext.ByteSize

  socketPath string

  host         string
  port         int
  listenLimit  int
  keepAlive    time.Duration
  readTimeout  time.Duration
  writeTimeout time.Duration

  tlsHost           string
  tlsPort           int
  tlsListenLimit    int
  tlsKeepAlive      time.Duration
  tlsReadTimeout    time.Duration
  tlsWriteTimeout   time.Duration
  tlsCertificate    string
  tlsCertificateKey string
  tlsCACertificate  string
)

{{ if .UseFlags}}
// StringSliceVar support for flag
type sliceValue []string

func newSliceValue(vals []string, p *[]string) *sliceValue {
	*p = vals
	return (*sliceValue)(p)
}

func (s *sliceValue) Set(val string) error {
	*s = sliceValue(strings.Split(val, ","))
	return nil
}

func (s *sliceValue) Get() interface{} { return []string(*s) }

func (s *sliceValue) String() string { return strings.Join([]string(*s), ",") }
// end StringSliceVar support for flag
{{ end }}

func stringEnvOverride(orig string, def string, keys ...string) string {
	for _, k := range keys {
		if os.Getenv(k) != "" {
			return os.Getenv(k)
		}
	}
	if def != "" && orig == "" {
		return def
	}
	return orig
}

func intEnvOverride(orig int, def int, keys ...string) int {
	for _, k := range keys {
		if os.Getenv(k) != "" {
			v, err := strconv.Atoi(os.Getenv(k))
			if err != nil {
				fmt.Fprintln(os.Stderr, k, "is not a valid number")
				os.Exit(1)
			}
			return v
		}
	}
	if def != 0 && orig == 0 {
		return def
	}
	return orig
}
{{ end }}

// NewServer creates a new api {{ humanize .Name }} server but does not configure it
func NewServer(api *{{ .APIPackageAlias }}.{{ pascalize .Name }}API) *Server {
	s := new(Server)

    {{- if .ExcludeSpec }}
    s.Spec = specFile
    {{- end }}

	s.shutdown = make(chan struct{})
	s.api = api
	s.interrupt = make(chan os.Signal, 1)
	return s
}

// ConfigureAPI configures the API and handlers.
func (s *Server) ConfigureAPI(cfg config.Service) {
	if s.api != nil {
		s.handler = configureAPI(s.api, cfg)
	}
}

// Server for the {{ humanize .Name }} API
type Server struct {
	GracefulTimeout  time.Duration

	Host string
	Port int
	ReadTimeout  time.Duration
	WriteTimeout time.Duration
	httpServerL   net.Listener

	{{ if .ExcludeSpec }}Spec {{ if not .UseGoStructFlags }}string{{ else }}flags.Filename `long:"spec" description:"the swagger specification to serve"`{{ end }}{{ end }}
	api               *{{ .APIPackageAlias }}.{{ pascalize .Name }}API
	handler           http.Handler
	hasListeners      bool
	shutdown          chan struct{}
	shuttingDown      int32
	interrupted       bool
	interrupt         chan os.Signal
}

// Logf logs message either via defined user logger or via system one if no user logger is defined.
func (s *Server) Logf(f string, args ...interface{}) {
	if s.api != nil && s.api.Logger != nil {
		s.api.Logger(f, args...)
	} else {
		log.Printf(f, args...)
	}
}

// Fatalf logs message either via defined user logger or via system one if no user logger is defined.
// Exits with non-zero status after printing
func (s *Server) Fatalf(f string, args ...interface{}) {
	if s.api != nil && s.api.Logger != nil {
		s.api.Logger(f, args...)
		os.Exit(1)
	} else {
		log.Fatalf(f, args...)
	}
}

// Serve the api
func (s *Server) Serve() (err error) {
	if !s.hasListeners {
		if err = s.Listen(); err != nil {
		  return err
		}
	}

	// set default handler, if none is set
	if s.handler == nil {
		if s.api == nil {
			return errors.New("can't create the default handler, as no api is set")
		}

		s.SetHandler(s.api.Serve(nil))
	}

	wg := new(sync.WaitGroup)
	once := new(sync.Once)
	signalNotify(s.interrupt)
	go handleInterrupt(once, s)

	servers := []*http.Server{}

    httpServer := new(http.Server)
    httpServer.ReadTimeout = s.ReadTimeout
    httpServer.WriteTimeout = s.WriteTimeout

    httpServer.Handler = s.handler

    configureServer(httpServer, "http", s.httpServerL.Addr().String())

    servers = append(servers, httpServer)
    wg.Add(1)
    s.Logf("Serving {{ humanize .Name }} at http://%s", s.httpServerL.Addr())
    go func(l net.Listener) {
        defer wg.Done()
        if err := httpServer.Serve(l); err != nil && err != http.ErrServerClosed {
            s.Fatalf("%v", err)
        }
        s.Logf("Stopped serving {{ humanize .Name }} at http://%s", l.Addr())
    }(s.httpServerL)

	wg.Add(1)
	go s.handleShutdown(wg, &servers)

	wg.Wait()
	return nil
}

// Listen creates the listeners for the server
func (s *Server) Listen() error {
  if s.hasListeners { // already done this
    return nil
  }

  listener, err := net.Listen("tcp", net.JoinHostPort(s.Host, strconv.Itoa(s.Port)))
  if err != nil {
    return err
  }

  h, p, err := swag.SplitHostPort(listener.Addr().String())
  if err != nil {
    return err
  }
  s.Host = h
  s.Port = p
  s.httpServerL = listener

  s.hasListeners = true
	return nil
}

// Shutdown server and clean up resources
func (s *Server) Shutdown() error {
	if atomic.CompareAndSwapInt32(&s.shuttingDown, 0, 1) {
		close(s.shutdown)
	}
	return nil
}

func (s *Server) handleShutdown(wg *sync.WaitGroup, serversPtr *[]*http.Server) {
	// wg.Done must occur last, after s.api.ServerShutdown()
	// (to preserve old behaviour)
	defer wg.Done()

	<-s.shutdown

	servers := *serversPtr

	ctx, cancel := context.WithTimeout(context.TODO(), s.GracefulTimeout)
	defer cancel()

  // first execute the pre-shutdown hook
	s.api.PreServerShutdown()

	shutdownChan := make(chan bool)
	for i := range servers {
		server := servers[i]
		go func() {
			var success bool
			defer func() {
				shutdownChan <- success
			}()
			if err := server.Shutdown(ctx); err != nil {
				// Error from closing listeners, or context timeout:
				s.Logf("HTTP server Shutdown: %v", err)
			} else {
				success = true
			}
		}()
	}

	// Wait until all listeners have successfully shut down before calling ServerShutdown
	success := true
	for range servers {
		success = success && <-shutdownChan
	}
	if success {
		s.api.ServerShutdown()
	}
}

// GetHandler returns a handler useful for testing
func (s *Server) GetHandler() http.Handler {
	return s.handler
}

// SetHandler allows for setting a http handler on this server
func (s *Server) SetHandler(handler http.Handler) {
	s.handler = handler
}

// HTTPListener returns the http listener
func (s *Server) HTTPListener() (net.Listener, error) {
	if !s.hasListeners {
		if err := s.Listen(); err != nil {
			return nil, err
		}
	}
	return s.httpServerL, nil
}

func handleInterrupt(once *sync.Once, s *Server) {
	once.Do(func(){
	for range s.interrupt {
		if s.interrupted {
			s.Logf("Server already shutting down")
			continue
		}
		s.interrupted = true
		s.Logf("Shutting down... ")
		if err := s.Shutdown(); err != nil {
			s.Logf("HTTP server Shutdown: %v", err)
		}
	}
	})
}

func signalNotify(interrupt chan<- os.Signal) {
	signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)
}
